<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux防火墙之iptables]]></title>
    <url>%2F2019%2F03%2F12%2FLinux%E9%98%B2%E7%81%AB%E5%A2%99%E4%B9%8Biptables%2F</url>
    <content type="text"><![CDATA[一、iptables概念1. iptable与Netfilter Netfilter是用来实现Linux内核中防火墙的Linux内核空间程序代码段。 iptables是用户管理Netfilter防火墙的用户程序。 2. iptables的组成1. 表 raw 仅用于配置数据包，以便它们免于连接跟踪。 filter 是默认表，决定是否允许数据包到达目的地。 nat用于网络地址转换（例如端口转发）。 mangle 用于数据包更改。 security用于强制访问控制网络规则（例如SELinux 2. 链表是由几个默认链组成的。 PREROUTING：存在于raw,mangle,nat INPUT:存在于mangle,filter,nat OUTPUT: 存在于mangle,filter FORWARD: 存在于raw,mangle,nat,filter POSTROUTING :存在于mangle，nat 自定义链 3. 规则包的过滤是基于规则的。规则由条件和target组成。很据匹配条件来匹配每一个流经此处的报文，一旦匹配成功则交给后面的target进行处理。 1.条件包的来源、类型(ICMP、TCP、UDP)、目标端口 2.目标 内建target ACCEPT DROP QUEUE RETURN 扩展target REJECT LOG 自定义链 3 自定义链 4. 数据经过iptables的流程 二、iptables操作1. 查1. 查看表的规则语法：iptables -t 表名 -L 123456789# iptables -t filter -LChain INPUT (policy ACCEPT)target prot opt source destinationChain FORWARD (policy ACCEPT)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destination 2. 查看表中指定链的规则语法：iptables -t 表名 -L 链名 123# iptables -t filter -L INPUTChain INPUT (policy ACCEPT)target prot opt source destination 3. 查看更详细的信息：-v1234# iptables -t filter -vL INPUTChain INPUT (policy ACCEPT 379 packets, 26956 bytes) pkts bytes target prot opt in out source destination 0 0 ACCEPT udp -- virbr0 any anywhere anywhere udp dpt:domain 各字段的含义： pkts：对应规则匹配到的报文数bytes：对应规则匹配到的报文包大小target：规则对应的targetprot：规则对应的协议opt：规则对应的选项in：数据包从哪个接口流入out：数据包从哪个接口流出source：源地址destination：目标地址 -n：不对IP地址反解 1234# iptables -t filter -vnL INPUTChain INPUT (policy ACCEPT 24M packets, 12G bytes) pkts bytes target prot opt in out source destination 0 0 ACCEPT udp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 udp dpt:53 -x: 显示精确数值 1234# iptables -t filter -vnL INPUT --line-number -xChain INPUT (policy ACCEPT 24568391 packets, 11707358586 bytes)num pkts bytes target prot opt in out source destination1 0 0 ACCEPT udp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 udp dpt:53 4. 显示规则编号1234567# iptables -t filter -vnL INPUT --line-numberChain INPUT (policy ACCEPT 24M packets, 12G bytes)num pkts bytes target prot opt in out source destination1 0 0 ACCEPT udp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 udp dpt:532 0 0 ACCEPT tcp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:533 0 0 ACCEPT udp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 udp dpt:674 0 0 ACCEPT tcp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:67 2. 增 插入一条规则(默认插入到第一行) 1语法：iptables -t 表名 -I 链名 匹配条件 -j 动作 1# iptables -t filter -I INPUT -s 172.16.10.102 -j DROP -t：操作的表-I：插入指定的链-s：源地址-j：匹配条件满足后执行的target(动作) 指定插入到某一行1# iptables -t filter -A INPUT 3 -s 172.16.10.103 -j ACCEPT 追加一条规则(追加到最后一行) 1语法：iptables -t 表名 -A 链名 匹配条件 -j 动作 1# iptables -t filter -A INPUT -s 172.16.10.102 -j ACCEPT 此时filter表的状态12345# iptables -nvL INPUTChain INPUT (policy ACCEPT 27 packets, 2764 bytes) pkts bytes target prot opt in out source destination 203 17052 DROP all -- * * 172.16.10.102 0.0.0.0/0 0 0 ACCEPT all -- * * 172.16.10.102 0.0.0.0/0 规则匹配顺序：从上到下匹配，如果前面的规则匹配成功就不会执行后面的规则了。 3. 删1语法：iptables -t 表名 -D 链名 匹配条件 -j 动作 根据规则的编号删除 1语法：# iptables -t filter -D INPUT 编号 示例：12# 删除第3条规则# iptables -t filter -D INPUT 3 根据具体的匹配条件与target删除 1# iptables -t filter -D INPUT -s 172.16.10.102 -j DROP 删除指定表中某条链的所有规则 1# iptables -t filter -F INPUT -F:flush 冲刷(删除)指定链中的所有规则 4. 改1语法：iptables -t 表名 -R 链名 规则序号 规则原来的匹配条件 -j 动作 修改规则 1# iptables -t filter -R INPUT 1 -s 172.16.10.100 -j ACCEPT -R：修改指定的链注意：必须要指定源地址 修改链的默认策略 1234567891011121314151617181920root@node1:~# iptables -LChain INPUT (policy ACCEPT)target prot opt source destinationChain FORWARD (policy ACCEPT)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destination# 将表中 FORWARD 中链的策略修改为 DROProot@node1:~# iptables -t filter -P FORWARD DROProot@node1:~# iptables -LChain INPUT (policy ACCEPT)target prot opt source destinationChain FORWARD (policy DROP)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destination 保存规则 ubuntu系统参考：https://help.ubuntu.com/community/IptablesHowTo 三、匹配条件1. 基本匹配1.1. 源地址 -s 指定IP 1# iptables -t filter -I INPUT -s 172.16.10.100,172.16.10.102 -j DROP 指定网段 1# iptables -t filter -I INPUT -s 172.16.10.0/24 -j DROP 取反 1# iptables -t filter -I INPUT ! -s 172.16.10.102 -j DROP 1.2. 目标地址 -d1# iptables -t filter -I INPUT -d 172.16.10.101 -j DROP 1.3. 协议类型 -p1# iptables -t filter -I INPUT -s 172.16.10.102 -d 172.16.10.101 -p tcp -j REJECT -p [tcp|udp|icmp|udplite|icmpv6|ah|sctp] 1.4. 网卡接口 -i/-o1# iptables -t filter -I INPUT -i eth0 -p icmp -j REJECT -i: 只能用于PREROUING、INPUT、FORWARD-o: 只能用于FORWARD、OUTPUT、POSTROUTING 2.扩展匹配扩展匹配条件使用时需要依赖一些扩展模块 2.1 tcp模块 目标端口 –dport 1# iptables -t filter -I INPUT -s 172.16.10.102 -m tcp -p tcp --dport 22 -j REJECT -m: 扩展模块名-p: 协议名称 源端口 –sport 1# iptables -t filter -I INPUT -s 172.16.10.102 -m tcp -p tcp --sport 22 -j ACCEPT 同时指定多个端口(连续的端口) 1# iptables -t filter -I INPUT -s 172.16.10.102 -m tcp -p tcp --sport 22:25 -j ACCEPT –tcp-flags 123# iptables -t filter -I INPUT -s 172.16.10.102 -m tcp -p tcp --dport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN -j REJECT或# iptables -t filter -I INPUT -s 172.16.10.102 -m tcp -p tcp --dport 22 --tcp-flags ALL SYN -j REJECT –tcp-flags 需要两个参数–tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN–tcp-flags 需要匹配TCP头中的哪些标志位 在第一部分的标志位列表中，哪些标志位必须为1 2.2 multiport模块(多个不连续的端口)1# iptables -t filter -I INPUT -s 172.16.10.102 -m multiport -p tcp --dport 22,80,8080 -j ACCEPT 2.3 udp扩展12# iptables -t filter -I INPUT -m udp -p udp --dport 137 -j ACCEPT# iptables -t filter -I INPUT -m udp -p udp --sport 138 -j ACCEPT 2.4 icmp扩展12# 别的主机ping不进来，自己向外请求回复的报文也无法进入防火墙# iptables -t filter -I INPUT -p icmp -j REJECT 只禁止被人ping 123# iptables -t filter -I INPUT -m icmp -p icmp --icmp-type 8/0 -j REJECT# 或# iptables -t filter -I INPUT -m icmp -p icmp --icmp-type "echo-request" -j REJECT 2.5 state扩展state模块可以实现连接追踪机制 连接状态：NEW、ESTABLISHED、RELATED、INVALID、UNTRACKED NEW：连接中的第一个包，状态就是NEW ESTABLISHED：NEW状态后面的包的状态 RELATED：一个服务建立了两个连接，连个连接中的某些报文直接有关系 INVALID：包无法被识别 UNTRACKED：报文未被追踪 实现只允许回应的报文通过防火墙(只能访问别人，别人不能访问自己) 12# iptables -t filter -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT# iptables -t filter -A INPUT -j REJECT 四、黑白名单白名单：放行匹配规则的包黑名单：拒绝匹配规则的包 白名单的实现： 1234# 放行22端口# iptables -I INPUT -p tcp --dport 22 -j ACCEPT# INPUT链的默认策略改为DROP# iptables -P INPUT DROP 不建议把默认策略设置为DROP，一旦执行iptables -F，任何包都进不去，ssh就会断开 优化方法 1234# 放行22端口# iptables -I INPUT -p tcp --dport 22 -j ACCEPT# 其他都拒绝# iptables -A INPUT -j REJECT 五、自定义链 自定义链的意义： 便于分类管理 自定义链不能直接使用，需要被默认链引用才可以使用 1. 创建12345678910111213# iptables -t filter -N IN_WEB# iptables -LChain INPUT (policy ACCEPT)target prot opt source destinationChain FORWARD (policy DROP)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destinationChain IN_WEB (0 references) # 引用计数为0target prot opt source destination -n： 自定义链的名称 2. 给自定义链添加规则12345root@node1:~# iptables -I IN_WEB -s 172.16.10.100 -j REJECTroot@node1:~# iptables -t filter -nvL IN_WEBChain IN_WEB (0 references) pkts bytes target prot opt in out source destination 0 0 REJECT all -- * * 172.16.10.100 0.0.0.0/0 reject-with icmp-port-unreachable 3. 引用自定义链123456789101112131415# iptables -I INPUT -p tcp --dport 80 -j IN_WEB# iptables -LChain INPUT (policy ACCEPT)target prot opt source destinationIN_WEB tcp -- anywhere anywhere tcp dpt:httpChain FORWARD (policy DROP)target prot opt source destinationChain OUTPUT (policy ACCEPT)target prot opt source destinationChain IN_WEB (1 references)target prot opt source destinationREJECT all -- 172.16.10.100 anywhere reject-with icmp-port-unreachable 4. 重命名自定义链1# iptables -E IN_WEB WEB 5. 删除删除条件 自定义链没有被任何默认链引用，即自定义链的引用计数为0 自定义链中没有任何规则 123# iptables -D INPUT 1# iptables -t filter -F WEB# iptables -X WEB 六、动作(target)1. 基础动作1. ACCEPT2. DROP2. 扩展动作2.1. REJECT常用选项：–reject-with 可以设置对方被拒绝时的提示信息 值：icmp-port-unreachable 默认icmp-net-unreachableicmp-host-unreachabeicmp-proto-unreachabeicmp-net-prohibitedicmp-admin-prohibited 2.2. LOG将符合条件的报文的相关信息记录到日志中 可用选项： –log-level: [emerg|alert|crit|error|warning|notice|info|debug]–log-prefix: 信息前缀（29个字符以内）12# 把想要主动连接22端口的报文及相关信息记录到日志中# iptables -I INPUT -p tcp --dport 22 -m state --state NEW -j LOG --log-prefix "want-in-from-port-22" 2.3 SNAT1# iptables -t nat -A POSTROUTING -s 10.1.0.0/16 -j SNAT --to-source 172.16.0.101 -t: 操作nat表-A: 将规则添加到POSTROUTING链末尾-s: 源地址-j: 使用 SNAT 动作–to-source: 把匹配到的报文修改为指定地址 2.4 SNAT1# iptables -t nat -I PREROUTING -d 172.16.10.101 -p tcp --dport 3389 -j DNAT --to-destination 10.1.1.6:3389 2.5 MASQUERADE与SNAT类似，但是可以动态的将源地址转换为可用的IP地址 1# iptables -t nat -A POSTROUTING -s 10.1.0.0/16 -o eth0 -j MASQUERADE 2.6 REDIRECT在本机进程端口映射 1# iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080 使用NAT需要开启转发： 1# echo 1 &gt; /proc/sys/net/ipv4/ip_forward 参考： https://wiki.archlinux.org/index.php/iptables 拒绝与禁止一个数据包的区别拒绝：丢弃数据包的同时给发送者返回一会ICMP错误消息 丢弃：数据包直接丢弃不返回任何通知 为了安全，通常直接丢弃，原因有3： 发送错误消息会使通信量加倍 响应的数据包可能是拒绝服务工具 即使一个错误的消息都会给攻击者提供潜在的有用信息]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[shell脚本规范]]></title>
    <url>%2F2019%2F02%2F23%2Fshell%E8%84%9A%E6%9C%AC%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[shell 脚本规范一、背景1.使用哪一种shell？必须使用bash shell 2.什么时候使用shell？ 数量相等较少的操作 脚本文件少于100行3.脚本文件扩展名是什么？shell脚本不要求有扩展名，或者以.sh结尾，库文件必须以.sh结尾，并且不可执行。二、环境STDOUT vs STDERR所有的错误信息都应该被导向STDERR。12345678err() &#123; echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $@" &gt;&amp;2&#125;if ! do_something; then err "Unable to do_something" exit "$&#123;E_DID_NOTHING&#125;"fi 三、注释1.文件头注释每一个文件的开头必须对文件进行描述基本格式：12345#!/bin/bash# Date :# Auth :# E-mail:# 功能描述 2.功能注释任何函数及库函数无论长短都必须注释。 3.实现部分注释注释较复杂、不易阅读、重要的部分 四、格式1. 缩进缩进4个空格，不允许使用制表符 2. 行的长度每行最大长度为80个字符 3. 管道如果一行容不下整个管道，把整个管道分割成每一行一个管道。 该规则同样适用于 || 和 &amp;&amp; 12345# Long commandscommand1 \ | command2 \ | command3 \ | command4 4.循环将 ; do , ; then 和 while , for , if 放在同一行，else单独一行。 12345if condition ;then commandelse commandfi 5.case如果命令只有一行，命令可以和;放在一行，其他情况下;单独一行。1234567891011case "$&#123;expression&#125;" in a) command ;; absolute) command ;; *) command ;;esac 6.变量除了单个字符的特殊变量和定位变量之外，其他变量在引用时必须用{}括起来 除了特殊情况下使用$*，其他情况都必须使用$@ 五、特性和BUG1. 命令替换使用 $(command) 而不是`command` 2. test，[和[[必须使用[[ 在 [[ 和 ]] 之间不会有路径名称扩展或单词分割发生，所以使用 [[ ... ]] 能够减少错误。而且 [[ ... ]] 允许正则表达式匹配，而 [ ... ] 不允许 3.测试字符串 使用 -z 或 -n 测试，不要使用 [[ “${my_var}” = “” ]] 4. eval避免使用eval 六 命名规范1.函数 函数名小写，并使用下划线分割单词 函数名和() 没有空格 大括号和函数名位于同一行2.变量名同函数名3.常量和环境变量名 全部大写 下划线分割4.源文件名 小写 需要分割使用下划线进行分割5.只读变量使用 readonly 或者 declare -r 来确保变量只读6.本地变量 使用 local 声明特定功能的变量。声明和赋值应该在不同行。7. 函数位置 所有函数放在常量下面8.主函数，main 文件最后一行1main "$@" 七 命令调用1.检查返回值对于非管道命令，使用 $? 或直接通过一个 if 语句来检查以保持其简洁。1234567891011if ! mv "$&#123;file_list&#125;" "$&#123;dest_dir&#125;/" ; then echo "Unable to move $&#123;file_list&#125; to $&#123;dest_dir&#125;" &gt;&amp;2 exit "$&#123;E_BAD_MOVE&#125;"fi# Ormv "$&#123;file_list&#125;" "$&#123;dest_dir&#125;/"if [[ "$?" -ne 0 ]]; then echo "Unable to move $&#123;file_list&#125; to $&#123;dest_dir&#125;" &gt;&amp;2 exit "$&#123;E_BAD_MOVE&#125;"fi 参考：https://google.github.io/styleguide/shell.xml]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell脚本规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub-Hexo-Next]]></title>
    <url>%2F2019%2F02%2F23%2FGitHub-Hexo-Next%2F</url>
    <content type="text"><![CDATA[安装Hexo1$ npm install -g hexo-cli 建站12345$ mkdir -p /workspace/blog$ cd /workspace$ hexo init blog/$ cd blog$ npm install 新建文章1$ hexo new [layout] &lt;title&gt; 生成静态文件1$ hexo generate 部署到github 安装$ npm install hexo-deployer-git –save 1$ npm install hexo-deployer-git --save 修改配置文件 123456$ vim _config.yaml 80 deploy: 81 type: git 82 repo: git@github.com:yuanzhigao/yuanzhigao.github.io.git 83 branch: master 84 message: "update blog" 配置Next主题123$ wget https://github.com/iissnan/hexo-theme-next/archive/v5.1.4.tar.gz$ tar zxf v5.1.4.tar.gz$ mv hexo-theme-next-5.1.4 /workspace/blog/themes/next 启用主题 12$ vim _config.yml theme: next 清除缓存 1$ hexo clean 添加标签页面1234567$ hexo new page tags# cat ~/blog/source/tags/index.md---title: 标签date: 2019-02-23 04:14:30type: "tags"--- 添加「分类」页面1234567$ hexo new page categories# cat ~/blog/source/categories/index.md---title: 分类date: 2019-02-23 04:15:06type: "categories"---]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
